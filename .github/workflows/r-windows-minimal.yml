name: R (Windows, portable MSYS2 via 000-msys2.R, verified toolchain)

on:
  push:
    branches: [ main, master ]
  pull_request:
  workflow_dispatch:

jobs:
  run-r-scripts:
    runs-on: windows-latest
    env:
      CRAN: https://cloud.r-project.org

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up R (no Rtools)
        uses: r-lib/actions/setup-r@v2
        with:
          r-version: 'release'
          rtools-version: 'none'

      # 1) Install MSYS2 using YOUR script
      - name: Run 000-msys2.R (install portable MSYS2 toolchain)
        shell: bash
        run: |
          set -e
          Rscript 000-msys2.R

      # 2) Detect the toolchain installed by your script
      - name: Detect MSYS2 gcc/make installed by 000-msys2.R
        id: detect
        shell: pwsh
        run: |
          # Find gcc now on PATH (added by your script). We expect ...\msys64\<triplet>\bin\gcc.exe
          $gccPath = $null
          try { $gccPath = (where.exe gcc | Select-Object -First 1) } catch {}
          if (-not $gccPath) { throw "gcc not found on PATH after running 000-msys2.R" }
          $gccDir = Split-Path $gccPath -Parent
          Write-Host "Detected gcc at: $gccPath"
          # Derive msys root and env triplet (ucrt64/mingw64 etc.)
          $tripletDir = Split-Path $gccDir -Parent
          $msysRoot = Split-Path $tripletDir -Parent
          $triplet = Split-Path $tripletDir -Leaf
          if (-not (Test-Path (Join-Path $msysRoot "usr\bin\bash.exe"))) {
            throw "Could not validate MSYS2 root at $msysRoot"
          }
          Write-Host "MSYS2_ROOT = $msysRoot"
          Write-Host "MSYS2_ENV  = $triplet"
          # Export for next steps
          echo "MSYS2_ROOT=$msysRoot" | Out-File -FilePath $env:GITHUB_ENV -Append
          echo "MSYS2_ENV=$triplet"   | Out-File -FilePath $env:GITHUB_ENV -Append
          echo "GCC_DIR=$gccDir"      | Out-File -FilePath $env:GITHUB_ENV -Append

      # 3) Build a sandbox PATH that forces use of YOUR MSYS2 only
      - name: Build sandbox PATH using your MSYS2
        shell: pwsh
        run: |
          $ucrtBin = "$env:MSYS2_ROOT\$env:MSYS2_ENV\bin"
          $msysUsr = "$env:MSYS2_ROOT\usr\bin"
          $newPath = @(
            $ucrtBin,
            $msysUsr,
            "$env:R_HOME\bin\x64",
            "$env:R_HOME\bin\i386",
            "C:\Windows\system32",
            "C:\Windows",
            "C:\Windows\System32\Wbem"
          ) -join ';'
          Write-Host "SANDBOX PATH = $newPath"
          echo "SANDBOX_PATH=$newPath" | Out-File -FilePath $env:GITHUB_ENV -Append

      # 4) Create ~/.R/Makevars so R compilers come from that same triplet
      - name: Create ~/.R/Makevars to lock your toolchain
        shell: pwsh
        run: |
          $rHome = $env:R_USER
          if (-not $rHome) { $rHome = "$env:USERPROFILE\Documents" }
          $rDir = Join-Path $rHome ".R"
          New-Item -ItemType Directory -Force -Path $rDir | Out-Null
          $mv = @"
          # Autogenerated: Force portable MSYS2 toolchain installed by 000-msys2.R
          BINPREF=$env:MSYS2_ROOT\$env:MSYS2_ENV\bin\
          CC=$env:MSYS2_ENV-w64-mingw32-gcc
          CXX=$env:MSYS2_ENV-w64-mingw32-g++
          CXX11=$env:MSYS2_ENV-w64-mingw32-g++
          CXX14=$env:MSYS2_ENV-w64-mingw32-g++
          CXX17=$env:MSYS2_ENV-w64-mingw32-g++
          FC=$env:MSYS2_ENV-w64-mingw32-gfortran
          AR=ar
          MAKE=make
          SHLIB_CXXLD=$(CXX)
          SHLIB_LD=$(CC)
          "@
          $mv | Out-File -FilePath (Join-Path $rDir "Makevars.ucrt") -Encoding ascii
          echo "R_MAKEVARS_USER=$rDir\Makevars.ucrt" | Out-File -FilePath $env:GITHUB_ENV -Append
          echo "BINPREF=$env:MSYS2_ROOT\$env:MSYS2_ENV\bin\" | Out-File -FilePath $env:GITHUB_ENV -Append

      # 5) Positive proof: gcc/make come from YOUR MSYS2, compile tiny program
      - name: Verify toolchain (path + compile hello.c)
        shell: bash
        env:
          PATH: ${{ env.SANDBOX_PATH }}
        run: |
          echo "which gcc: $(which gcc)"
          echo "which make: $(which make)"
          gcc --version
          make --version
          cat > hello.c <<'C'
          #include <stdio.h>
          int main(){ puts("hello from your portable gcc"); return 0; }
          C
          gcc hello.c -o hello.exe && ./hello.exe

      # 6) dynr install / load
      - name: Run 001-dynr.R (install/load dynr)
        shell: bash
        env:
          PATH: ${{ env.SANDBOX_PATH }}
          R_MAKEVARS_USER: ${{ env.R_MAKEVARS_USER }}
          BINPREF: ${{ env.BINPREF }}
        run: |
          Rscript 001-dynr.R

      # 7) Compile your Linear SDE using ONLY that toolchain (and print env so it's auditable)
      - name: Run 003-linear-sde.R with verified toolchain
        shell: bash
        env:
          PATH: ${{ env.SANDBOX_PATH }}
          R_MAKEVARS_USER: ${{ env.R_MAKEVARS_USER }}
          BINPREF: ${{ env.BINPREF }}
        run: |
          echo "---- ENV PROOF FOR BUILD ----"
          echo "PATH=$PATH"
          Rscript -e 'print(Sys.getenv(c("R_MAKEVARS_USER","BINPREF","PATH")))'
          echo "which gcc: $(which gcc)"
          gcc --version
          echo "--------------------------------"
          Rscript 003-linear-sde.R

      - name: Save logs/artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: r-logs
          path: |
            ./*.Rout
            ./dynr*.log
            ./LinearSDE.c
            ./LinearSDE.*.txt
            ./hello.exe
            ./hello.c
          if-no-files-found: ignore
